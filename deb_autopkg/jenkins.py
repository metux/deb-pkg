from sys import stderr
from string import Template
from util.log import info, warn
from util import list2text, dict2text
import conf
from builder import Builder
from util.aptly import Aptly

job_template = Template("""
folder('${folder}')

job('${job_name}') {
    description('''This job is autogenerated by metux Debkins.
Do not modify.
<hr/>
<table>
    <tr><th>name:</th><td>     ${package_ident}</td></tr>
    <tr><th>package:</th><td>  ${package_name}</td></tr>
    <tr><th>version:</th><td>  ${package_version}</td></tr>
    <tr><th>depends:</th><td>  ${depends}</td></tr>
    <tr><th>branch:</th><td>   ${autobuild_branch}</td></tr>
    <tr><th>target:</th><td>   ${target_name}</td></tr>
    <tr><th>aptrepo:</th><td>  ${target_aptrepo}</td></tr>
</table>
''')
    triggers {
        scm('* * * * *')
    }
    multiscm {
        git {
            remote {
                url('${deb_pkg_url}')
                branch('${deb_pkg_branch}')
            }
        }
        git {
//            cloneTimeout(60)
            remote {
                url('${autobuild_repo_url}')
                branch('${autobuild_repo_branch}')
            }
            extensions {
                relativeTargetDirectory('${package_dir}')
                cloneOptions {
                    shallow()
                }
            }
        }
    }
    environmentVariables(DCK_BUILDPACKAGE_HEAVY_COPY: 'yes')
    steps {
        println('Building package: ${package_ident}')
        shell('echo DCK_BUILDPACKAGE_HEAVY_COPY=$$DCK_BUILDPACKAGE_HEAVY_COPY')
        shell('./debkins.build ${package_ident} ${target_name}')
    }
    publishers {
        chucknorris()
        archiveArtifacts('.aptrepo/**/*.deb')
    }
}
""")

class JobGenerator:

    def __init__(self, conf):
        self.conf = conf
        self._my_config = conf
        self._my_debcf = self._my_config.get_debpkg_config()

    def gen_pkg_obj(self, pkg, aptrepo):
        autobuild_branch = pkg.get_autobuild_branch()
        gitrepo = pkg.get_repo_conf()
        autobuild_repo_branch = None
        pool_name = aptrepo.get_pool_name()

        deb_pkg_url = "https://github.com/metux/deb-pkg.git"
        deb_pkg_branch = "debkins"

        if autobuild_branch is None:
            return "// Skipping project "+pkg.name+" (no autobuild branch defined)\n"

        for walk in gitrepo['remotes']:
            if (autobuild_branch.find(walk+"/") == 0):
                autobuild_repo_branch = autobuild_branch[len(walk)+1:]
                autobuild_repo_url = gitrepo['remotes'][walk]['url']

        if autobuild_repo_branch is None:
            return "// Skipping project "+pkg.name+" (autobuild branch not found on any remote)\n"

        out = ''

        # FIXME: dont use the targets from the pool anymore, but the aptrepo
        # hmm, probably we need to inject the target name from the aptrepo config
        for target in self._my_debcf.get_pool(pool_name).get_targets():
            folder_name = "pool."+pool_name+"."+target.get_target_name()
            job_name = folder_name+"/"+pkg.name.replace('@','+')
            out += job_template.substitute({
                'target_name':              target.get_target_name(),
                'target_aptrepo':           target.get_aptrepo_path(),
                'folder':                   folder_name,
                'job_name':                 job_name,
                'configfile':               'cf/default.yaml',
                'package_ident':            pkg.name,
                'package_dir':              pkg.git_repo_dir(),
                'package_name':             pkg.package_name,
                'package_version':          pkg.package_version,
                'depends':                  str(pkg.get_depends_list()),
                'autobuild_branch':         autobuild_branch,
                'autobuild_repo_branch':    autobuild_repo_branch,
                'autobuild_repo_url':       autobuild_repo_url,
                'deb_pkg_branch' :          deb_pkg_branch,
                'deb_pkg_url':              deb_pkg_url,
            })

        return out

    def get_aptrepo_packages(self, repo):
        return self._my_debcf.get_pool(repo.get_pool_name()).get_packages()

    def gen_aptrepo(self, aptrepo):
        return list2text(
            self.get_aptrepo_packages(aptrepo),
            lambda pkg: self.gen_pkg_obj(pkg, aptrepo))

    def generate_jobs(self):
        return dict2text(self._my_debcf.get_apt_repos(), self.gen_aptrepo)

class DebkinsSpec:
    def __init__(self, spec):
        self._my_spec = spec
        self._my_repos = []
        self._my_config = conf.load(self._my_spec['config'])

    def get_debpkg_config(self):
        return self._my_config

    def get_apt_repos(self):
        return self._my_config.get_apt_repos()

import yaml
import subprocess

class Debkins:
    def __init__(self, cfname = 'cf/debkins.yaml'):
        with open(cfname) as f:
            self._my_spec = yaml.safe_load(f)

        self._my_config = DebkinsSpec(self._my_spec)

    def generate_jobs(self, cfname, git_url, git_ref):
        return JobGenerator(self._my_config).generate_jobs()

    def get_aptrepo(self, aptrepo_name):
        return self._my_config.get_apt_repos()[aptrepo_name]

    def scan_deb(self):
        return subprocess.check_output(['find', '.aptrepo', '-name', '*.deb']).splitlines()

    def build_package(self, pkg_name, aptrepo_name):
        subprocess.call(['rm', '-Rf', '.aptrepo', '.stat', 'pkg/__dckbp__.git/'])
        aptly = Aptly(self.get_aptrepo(aptrepo_name))
        # fixme: need to take care of the target
        # build package for target instead of all
        Builder(self._my_config.get_debpkg_config()).build_package(pkg_name, None, { 'dontclone': True })
        for deb in self.scan_deb():
            aptly.add_pkg(deb)
